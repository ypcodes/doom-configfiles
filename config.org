#+title: My Doom Emacs Configuration
#+startup: overview


* Packages needs to install
:PROPERTIES:
:ID:       37071488-e0f4-47ba-be7c-71616230ee3f
:END:
#+begin_src emacs-lisp :tangle (expand-file-name "packages.el" doom-private-dir)
;; -*- no-byte-compile: t; -*-
;;; $DOOMDIR/packages.el
(package! eaf
  :recipe (:host github :repo "emacs-eaf/emacs-application-framework"
           :files ("*")
           :post-build (progn
                         (async-shell-command "python install-eaf.py"))))

(package! calctex :recipe (:host github :repo "johnbcoughlin/calctex"
                           :files ("*.el" "calctex/*.el" "calctex-contrib/*.el" "org-calctex/*.el" "vendor")))

(package! org-transclusion :recipe (:host github :repo "nobiot/org-transclusion"))
(package! org-pandoc-import
  :recipe (:host github
           :repo "tecosaur/org-pandoc-import"
           :files ("*.el" "filters" "preprocessors")))

(package! org-modern)

(package! nano-theme
  :recipe (:host github
           :repo "rougier/nano-theme"))
(package! nano-modeline)
(package! nano-vertico
  :recipe (:host github
           :repo "rougier/nano-vertico"))

(package! solo-jazz-theme)

(package! catppuccin-theme)
(package! kaolin-themes)

(package! pyim)
(package! pyim-basedict)

(package! github-theme)
(package! xclip)

(package! image-roll :recipe
  (:host github
   :repo "dalanicolai/image-roll.el"))

(package! ob-mathematica)
(package! wolfram-mode)

(unpin! pdf-tools)
(package! pdf-tools :recipe (:host github :repo "vedang/pdf-tools"))

(package! org-ql
  :recipe (:host github :repo "alphapapa/org-ql"
           :files  (:defaults (:exclude "helm-org-ql.el"))))
(package! org-contrib :recipe (:host github :repo "emacsmirror/org-contrib"))
(package! draft-mode)
(package! empv :recipe (:host github :repo "isamert/empv.el"))
#+end_src

* script
:PROPERTIES:
:ID:       268bcd35-f277-4c19-a151-5893af345149
:END:
** visual script
#+begin_src python :tangle (expand-file-name "scripts/visualize_novel.py" doom-private-dir) :shebang "#!/usr/bin/env python"
  # -*- coding: utf-8 -*-

  import sys
  import pandas as pd
  import matplotlib.pyplot as plt
  import re
  import os
  import networkx as nx
  from graphviz import Digraph # 需要安装 graphviz Python 库和系统程序

  # --- Matplotlib 设置 (保持不变) ---
  def set_chinese_font():
      """尝试设置一个可用的中文字体。"""
      supported_fonts = ['SimHei', 'Microsoft YaHei', 'WenQuanYi Zen Hei', 'KaiTi']
      for font in supported_fonts:
          try:
              plt.rcParams['font.sans-serif'] = [font]
              plt.rcParams['axes.unicode_minus'] = False
              print(f"成功设置字体: {font}")
              return
          except Exception:
              continue
      print("警告: 未找到支持的常用中文字体，统计图表中的中文可能显示为方块。")

  # --- 数据处理函数 (保持不变) ---
  def count_characters(character_string):
      if pd.isna(character_string) or not isinstance(character_string, str):
          return 0
      characters = re.split(r'[，,]\s*', character_string)
      non_empty_characters = [char for char in characters if char]
      return len(non_empty_characters)

  # --- 新增：创建场景流程图的函数 ---
  def create_scene_graph(df, output_dir):
      """
      使用 Graphviz 创建并渲染场景流程图。
      """
      print("正在创建场景流程图...")
      dot = Digraph('NovelSceneFlow', comment='Novel Scene Flow Graph')
      dot.attr(rankdir='TB', splines='ortho', nodesep='0.5', ranksep='1.0') # TB=Top to Bottom
      dot.attr('node', shape='box', style='rounded,filled', fontname='SimHei') # 确保节点字体也设置正确
      dot.attr('edge', fontname='SimHei')

      # 定义节点颜色
      status_colors = {
          'idea': '#E0E0E0',    # 灰色
          'draft': '#BBDEFB',   # 浅蓝
          'revise': '#FFF59D',  # 黄色
          'done': '#C8E6C9',    # 浅绿
      }

      # 1. 添加所有场景作为节点
      for _, scene in df.iterrows():
          scene_id = scene.get(':id', '')
          if not scene_id: continue # 跳过没有ID的行

          title = scene.get(':title', '无标题')
          status = scene.get(':status', 'idea')
          color = status_colors.get(status, '#FFFFFF') # 默认为白色

          # 节点标签可以包含多行信息
          label = f"{title}\n<{scene_id}>"

          dot.node(scene_id, label=label, fillcolor=color)

      # 2. 添加从 :Next: 属性定义的边
      for _, scene in df.iterrows():
          current_id = scene.get(':id', '')
          next_ids_str = scene.get(':next', '')
          if not current_id or pd.isna(next_ids_str):
              continue

          # 支持用逗号（中英文）分隔的多个 next 场景
          next_ids = re.split(r'[，,]\s*', str(next_ids_str))

          for next_id in next_ids:
              if next_id and next_id in df[':id'].values:
                  dot.edge(current_id, next_id)

      # 3. 渲染并保存 SVG 文件
      output_filename_base = os.path.join(output_dir, 'scene_flow_graph')
      try:
          dot.render(output_filename_base, format='svg', cleanup=True)
          print(f"场景流程图已保存到: {output_filename_base}.svg")
      except Exception as e:
          print(f"错误: 无法渲染 Graphviz 图表。请确保 Graphviz 已正确安装并已添加到系统 PATH。")
          print(f"原始错误: {e}")


  # --- 主分析函数 (保持不变) ---
  def analyze_and_plot_stats(df, output_dir):
      """
      读取 DataFrame, 分析数据, 并生成统计图表。
      """
      # ... (这部分代码和之前完全一样) ...
      required_cols = ['title', 'tensionscore', 'words', 'character_count']
      for col in required_cols:
          if col not in df.columns:
              print(f"错误: CSV文件中缺少关键列 '{col}'。请检查 Emacs Lisp 导出脚本。")
              return # 提前退出，避免崩溃

      scene_labels = [str(title)[:10] + '...' if len(str(title)) > 10 else str(title) for title in df['title']]
      fig, axs = plt.subplots(3, 1, figsize=(12, 18), tight_layout=True)
      fig.suptitle('小说场景数据分析报告', fontsize=20)
      axs[0].plot(scene_labels, df['TensionScore'], marker='o', linestyle='-', color='r')
      axs[0].set_title('场景张力曲线 (Tension Score)')
      axs[0].set_ylabel('张力值 (1-10)')
      axs[0].grid(True, linestyle='--', alpha=0.6)
      axs[0].tick_params(axis='x', rotation=45)
      axs[1].bar(scene_labels, df['words'], color='b', alpha=0.7)
      axs[1].set_title('各场景预估字数')
      axs[1].set_ylabel('字数')
      axs[1].grid(True, axis='y', linestyle='--', alpha=0.6)
      axs[1].tick_params(axis='x', rotation=45)
      axs[2].bar(scene_labels, df['character_count'], color='g', alpha=0.7)
      axs[2].set_title('各场景出场角色数')
      axs[2].set_ylabel('角色数量')
      axs[2].grid(True, axis='y', linestyle='--', alpha=0.6)
      axs[2].tick_params(axis='x', rotation=45)
      output_filename = os.path.join(output_dir, 'novel_analysis_report.png')
      plt.savefig(output_filename)
      print(f"统计报告已保存到: {output_filename}")
      plt.show()

  # --- 主执行入口 (修改后) ---
  def main(csv_path):
      if not os.path.exists(csv_path):
          print(f"错误: 文件未找到 {csv_path}")
          return

      # 1. 读取和预处理数据
      df = pd.read_csv(csv_path)

      # --- 这是关键的修复和增强 ---
      # 将所有列名强制转换为小写，一劳永逸地解决大小写问题
      df.columns = df.columns.str.lower()

      # 现在可以安全地访问 'tensionscore'
      df['tensionscore'] = pd.to_numeric(df[':tensionscore'], errors='coerce').fillna(0)
      df['words'] = pd.to_numeric(df[':words'], errors='coerce').fillna(0)
      df['character_count'] = df[':characters'].apply(count_characters)

      output_dir = os.path.dirname(csv_path)

      # 2. 生成两种可视化
      create_scene_graph(df, output_dir)
      analyze_and_plot_stats(df, output_dir)


  if __name__ == "__main__":
      set_chinese_font()
      if len(sys.argv) < 2:
          print("用法: python visualize_novel.py <path_to_csv_file>")
      else:
          csv_file_path = sys.argv[1]
          main(csv_file_path)
#+end_src
** export to excel
这个脚本负责将导出的 scenes_data.csv 文件转换为一个格式精美的 Excel (.xlsx) 文件。

#+begin_src python :tangle (expand-file-name "scripts/csv_to_styled_xlsx.py" doom-private-dir) :shebang "#!/usr/bin/env python3"
  # -*- coding: utf-8 -*-

  import sys
  import os
  import pandas as pd

  def get_col_widths(df):
      """计算每列的最佳宽度。"""
      # 首先获取列名的宽度
      widths = {col: len(str(col)) for col in df.columns}
      # 遍历每一行，更新最大宽度
      for index, row in df.iterrows():
          for col, value in row.items():
              widths[col] = max(widths[col], len(str(value)))
      # 为宽度增加一点余量
      return {col: width + 2 for col, width in widths.items()}

  def csv_to_excel(csv_path):
      """
      读取 CSV 文件并将其转换为一个带有高级格式的 XLSX 文件。
      """
      if not os.path.exists(csv_path):
          print(f"错误: 文件未找到 {csv_path}")
          return

      output_path = os.path.splitext(csv_path)[0] + '.xlsx'
      df = pd.read_csv(csv_path)

      # 创建一个 Pandas Excel writer 对象，使用 XlsxWriter 作为引擎
      writer = pd.ExcelWriter(output_path, engine='xlsxwriter')

      # 将 dataframe 写入 Excel，不包含 pandas 的 index
      df.to_excel(writer, sheet_name='Scenes', index=False)

      # 从 writer 中获取 workbook 和 worksheet 对象
      workbook = writer.book
      worksheet = writer.sheets['Scenes']

      # --- 定义格式 (Excel "设置") ---
      header_format = workbook.add_format({
          'bold': True,
          'text_wrap': True,
          'valign': 'top',
          'fg_color': '#D7E4BC', # 浅绿色背景
          'border': 1
      })

      # 为长文本列定义自动换行格式
      wrap_format = workbook.add_format({'valign': 'top', 'text_wrap': True})

      # 为居中的短文本列定义格式
      center_format = workbook.add_format({'align': 'center', 'valign': 'vcenter'})

      # --- 应用格式 ---
      # 1. 写入并格式化表头
      for col_num, value in enumerate(df.columns.values):
          worksheet.write(0, col_num, value, header_format)

      # 2. 设置列宽和特定列的格式
      col_widths = get_col_widths(df)
      long_text_cols = ['title', 'goal', 'conflict', 'outcome', 'summary', 'notes', 'characters']
      center_cols = ['status', 'arc', 'pov']

      for i, col_name in enumerate(df.columns):
          width = col_widths.get(col_name, 10) # 默认宽度为10
          if col_name in long_text_cols:
              # 对于长文本，限制最大宽度并应用换行
              worksheet.set_column(i, i, min(width, 50), wrap_format)
          elif col_name in center_cols:
              worksheet.set_column(i, i, width, center_format)
          else:
              worksheet.set_column(i, i, width)

      # 3. 启用筛选功能
      worksheet.autofilter(0, 0, len(df), len(df.columns) - 1)

      # 4. 冻结首行 (表头)
      worksheet.freeze_panes(1, 0)

      # 保存 Excel 文件
      writer.close()
      print(f"成功将数据导出到精美的 Excel 文件: {output_path}")

  if __name__ == "__main__":
      if len(sys.argv) < 2:
          print("用法: python csv_to_styled_xlsx.py <path_to_csv_file>")
      else:
          csv_file_path = sys.argv[1]
          csv_to_excel(csv_file_path)

#+end_src
** set to default editor

just run directly
#+begin_src sh :tangle (expand-file-name "scripts/modify_default_mime_type.sh" doom-private-dir) :shebang "#!/usr/bin/env sh"
for type in text/x-python text/x-shellscript text/x-c text/x-c++src text/x-markdown text/x-json application/json application/xml text/x-yaml; do
    xdg-mime default emacsclient.desktop $type
done

xdg-mime default org.mozilla.zen.desktop x-scheme-handler/http
xdg-mime default org.mozilla.zen.desktop x-scheme-handler/https
xdg-mime default org.mozilla.zen.desktop text/html
#+end_src

* Basics
:PROPERTIES:
:ID:       L20251017.160037_basics
:END:
Some functionality uses this to identify you, e.g. GPG configuration, email
clients, file templates and snippets. It is optional.
#+begin_src emacs-lisp
(setq user-full-name "Peng Ye"
      user-mail-address "yepeng230@gmail.com")

#+end_src

Doom exposes five (optional) variables for controlling fonts in Doom:

- `doom-font' -- the primary font to use
- `doom-variable-pitch-font' -- a non-monospace font (where applicable)
- `doom-big-font' -- used for `doom-big-font-mode'; use this for
  presentations or streaming.
- `doom-unicode-font' -- for unicode glyphs
- `doom-serif-font' -- for the `fixed-pitch-serif' face

See 'C-h v doom-font' for documentation and more examples of what they
accept. For example:


If you or Emacs can't find your font, use 'M-x describe-font' to look them
up, `M-x eval-region' to execute elisp code, and 'M-x doom/reload-font' to
refresh your font settings. If Emacs still can't find your font, it likely
wasn't installed correctly. Font issues are rarely Doom issues!

There are two ways to load a theme. Both assume the theme is installed and
available. You can either set `doom-theme' or manually load a theme with the
`load-theme' function. This is the default:
#+begin_src emacs-lisp
(setq doom-theme 'doom-one)
#+end_src
This determines the style of line numbers in effect. If set to `nil', line
numbers are disabled. For relative line numbers, set this to `relative'.
#+begin_src emacs-lisp
(setq display-line-numbers-type 't)
#+end_src

If you use `org' and don't want your org files in the default location below,
change `org-directory'. It must be set before org loads!
#+begin_src emacs-lisp
(setq org-directory "~/projects/org/"
      org-roam-directory "~/projects/org/roam")
#+end_src

Here are some additional functions/macros that will help you configure Doom.

- `load!' for loading external *.el files relative to this one
- `use-package!' for configuring packages
- `after!' for running code after a package has loaded
- `add-load-path!' for adding directories to the `load-path', relative to
  this file. Emacs searches the `load-path' when you load packages with
  `require' or `use-package'.
- `map!' for binding new keys

* Better defaults
:PROPERTIES:
:ID:       L20251017.162201_better defaults
:END:
#+begin_src emacs-lisp
(add-to-list 'default-frame-alist '(height . 24))
(add-to-list 'default-frame-alist '(width . 80))
#+end_src

#+begin_src emacs-lisp
(setq-default custom-file (expand-file-name ".custom.el" doom-private-dir))
(when (file-exists-p custom-file)
  (load custom-file))
#+end_src

#+begin_src emacs-lisp
(setq evil-vsplit-window-right t
      evil-split-window-below t)
#+end_src

#+begin_src emacs-lisp
(defadvice! prompt-for-buffer (&rest _)
  :after '(evil-window-split evil-window-vsplit)
  (consult-buffer))
#+end_src

#+begin_src emacs-lisp
(map! :map evil-window-map
      "SPC" #'rotate-layout
      ;; Navigation
      "<left>"     #'evil-window-left
      "<down>"     #'evil-window-down
      "<up>"       #'evil-window-up
      "<right>"    #'evil-window-right
      ;; Swapping windows
      "C-<left>"       #'+evil/window-move-left
      "C-<down>"       #'+evil/window-move-down
      "C-<up>"         #'+evil/window-move-up
      "C-<right>"      #'+evil/window-move-right)
#+end_src
* Font config
#+begin_src emacs-lisp
(defun my-cjk-font-setup ()
  (dolist (charset '(kana han cjk-misc bopomofo))
    (set-fontset-font t charset (font-spec :family "Noto Sans CJK SC"))))

(add-hook 'after-setting-font-hook #'my-cjk-font-setup)
;;(setq face-font-rescale-alist '(("Noto Sans CJK SC" . 1.2)))
#+end_src

* Dashboard setup
Copy from [[github:tecosaur/emacs-config]]

Setup Start
#+begin_src emacs-lisp
(defvar fancy-splash-image-directory
  (expand-file-name "misc/splash-images/" doom-private-dir)
  "Directory in which to look for splash image templates.")
#+end_src

#+begin_src emacs-lisp
(defvar fancy-splash-image-template
  (expand-file-name "emacs-e-template.svg" fancy-splash-image-directory)
  "Default template svg used for the splash image.
Colours are substituted as per `fancy-splash-template-colours'.")
#+end_src

#+begin_src emacs-lisp
(defvar fancy-splash-template-colours
  '(("#111112" :face default   :attr :foreground)
    ("#8b8c8d" :face shadow)
    ("#eeeeef" :face default   :attr :background)
    ("#e66100" :face highlight :attr :background)
    ("#1c71d8" :face font-lock-keyword-face)
    ("#f5c211" :face font-lock-type-face)
    ("#813d9c" :face font-lock-constant-face)
    ("#865e3c" :face font-lock-function-name-face)
    ("#2ec27e" :face font-lock-string-face)
    ("#c01c28" :face error)
    ("#000001" :face ansi-color-black)
    ("#ff0000" :face ansi-color-red)
    ("#ff00ff" :face ansi-color-magenta)
    ("#00ff00" :face ansi-color-green)
    ("#ffff00" :face ansi-color-yellow)
    ("#0000ff" :face ansi-color-blue)
    ("#00ffff" :face ansi-color-cyan)
    ("#fffffe" :face ansi-color-white))
  "Alist of colour-replacement plists.
Each plist is of the form (\"$placeholder\" :doom-color 'key :face 'face).
If the current theme is a doom theme :doom-color will be used,
otherwise the colour will be face foreground.")
(defun fancy-splash-check-buffer ()
  "Check the current SVG buffer for bad colours."
  (interactive)
  (when (eq major-mode 'image-mode)
    (xml-mode))
  (when (and (featurep 'rainbow-mode)
             (not (bound-and-true-p rainbow-mode)))
    (rainbow-mode 1))
  (let* ((colours (mapcar #'car fancy-splash-template-colours))
         (colourise-hex
          (lambda (hex)
            (propertize
             hex
             'face `((:foreground
                      ,(if (< 0.5
                              (cl-destructuring-bind (r g b) (x-color-values hex)
                                ;; Values taken from `rainbow-color-luminance'
                                (/ (+ (* .2126 r) (* .7152 g) (* .0722 b))
                                   (* 256 255 1.0))))
                           "white" "black")
                      (:background ,hex))))))
         (cn 96)
         (colour-menu-entries
          (mapcar
           (lambda (colour)
             (cl-incf cn)
             (cons cn
                   (cons
                    (substring-no-properties colour)
                    (format " (%s) %s %s"
                            (propertize (char-to-string cn)
                                        'face 'font-lock-keyword-face)
                            (funcall colourise-hex colour)
                            (propertize
                             (symbol-name
                              (plist-get
                               (cdr (assoc colour fancy-splash-template-colours))
                               :face))
                             'face 'shadow)))))
           colours))
         (colour-menu-template
          (format
           "Colour %%s is unexpected! Should this be one of the following?\n
%s
 %s to ignore
 %s to quit"
           (mapconcat
            #'cddr
            colour-menu-entries
            "\n")
           (propertize "SPC" 'face 'font-lock-keyword-face)
           (propertize "ESC" 'face 'font-lock-keyword-face)))
         (colour-menu-choice-keys
          (append (mapcar #'car colour-menu-entries)
                  (list ?\s)))
         (buf (get-buffer-create "*fancy-splash-lint-colours-popup*"))
         (good-colour-p
          (lambda (colour)
            (or (assoc colour fancy-splash-template-colours)
                ;; Check if greyscale
                (or (and (= (length colour) 4)
                         (= (aref colour 1)   ; r
                            (aref colour 2)   ; g
                            (aref colour 3))) ; b
                    (and (= (length colour) 7)
                         (string= (substring colour 1 3)       ; rr =
                                  (substring colour 3 5))      ; gg
                         (string= (substring colour 3 5)       ; gg =
                                  (substring colour 5 7))))))) ; bb
         (prompt-to-replace
          (lambda (target)
            (with-current-buffer buf
              (erase-buffer)
              (insert (format colour-menu-template
                              (funcall colourise-hex target)))
              (setq-local cursor-type nil)
              (set-buffer-modified-p nil)
              (goto-char (point-min)))
            (save-window-excursion
              (pop-to-buffer buf)
              (fit-window-to-buffer (get-buffer-window buf))
              (car (alist-get
                    (read-char-choice
                     (format "Select replacement, %s-%s or SPC: "
                             (char-to-string (caar colour-menu-entries))
                             (char-to-string (caar (last colour-menu-entries))))
                     colour-menu-choice-keys)
                    colour-menu-entries))))))
    (save-excursion
      (goto-char (point-min))
      (while (re-search-forward "#[0-9A-Fa-f]\\{6\\}\\|#[0-9A-Fa-f]\\{3\\}" nil t)
        (recenter)
        (let* ((colour (match-string 0))
               (replacement (and (not (funcall good-colour-p colour))
                                 (funcall prompt-to-replace colour))))
          (when replacement
            (replace-match replacement t t))))
      (message "Done"))))
(defvar fancy-splash-cache-dir (expand-file-name "theme-splashes/" doom-cache-dir))
#+end_src

#+begin_src emacs-lisp
(defvar fancy-splash-sizes
  `((:height 300 :min-height 50 :padding (0 . 2))
    (:height 250 :min-height 42 :padding (2 . 4))
    (:height 200 :min-height 35 :padding (3 . 3))
    (:height 150 :min-height 28 :padding (3 . 3))
    (:height 100 :min-height 18 :padding (2 . 2))
    (:height 75  :min-height 15 :padding (2 . 1))
    (:height 50  :min-height 10 :padding (1 . 0))
    (:height 1   :min-height 0  :padding (0 . 0)))
  "List of plists specifying image sizing states.
Each plist should have the following properties:
- :height, the height of the image
- :min-height, the minimum `frame-height' for image
- :padding, a `+doom-dashboard-banner-padding' (top . bottom) padding
  specification to apply
Optionally, each plist may set the following two properties:
- :template, a non-default template file
- :file, a file to use instead of template")
#+end_src

#+begin_src emacs-lisp
(defun fancy-splash-filename (theme template height)
  "Get the file name for the splash image with THEME and of HEIGHT."
  (expand-file-name (format "%s-%s-%d.svg" theme (file-name-base template) height) fancy-splash-cache-dir))
#+end_src


#+begin_src emacs-lisp
(defun fancy-splash-generate-image (template height)
  "Create a themed image from TEMPLATE of HEIGHT.
The theming is performed using `fancy-splash-template-colours'
and the current theme."
  (with-temp-buffer
    (insert-file-contents template)
    (goto-char (point-min))
    (if (re-search-forward "$height" nil t)
        (replace-match (number-to-string height) t t)
      (if (re-search-forward "height=\"100\\(?:\\.0[0-9]*\\)?\"" nil t)
          (progn
            (replace-match (format "height=\"%s\"" height) t t)
            (goto-char (point-min))
            (when (re-search-forward "\\([ \t\n]\\)width=\"[\\.0-9]+\"[ \t\n]*" nil t)
              (replace-match "\\1")))
        (warn "Warning! fancy splash template: neither $height nor height=100 not found in %s" template)))
    (dolist (substitution fancy-splash-template-colours)
      (goto-char (point-min))
      (let* ((replacement-colour
              (face-attribute (plist-get (cdr substitution) :face)
                              (or (plist-get (cdr substitution) :attr) :foreground)
                              nil 'default))
             (replacement-hex
              (if (string-prefix-p "#" replacement-colour)
                  replacement-colour
                (apply 'format "#%02x%02x%02x"
                       (mapcar (lambda (c) (ash c -8))
                               (color-values replacement-colour))))))
        (while (search-forward (car substitution) nil t)
          (replace-match replacement-hex nil nil))))
    (unless (file-exists-p fancy-splash-cache-dir)
      (make-directory fancy-splash-cache-dir t))
    (let ((inhibit-message t))
      (write-region nil nil (fancy-splash-filename (car custom-enabled-themes) template height)))))
(defun fancy-splash-generate-all-images ()
  "Perform `fancy-splash-generate-image' in bulk."
  (dolist (size fancy-splash-sizes)
    (unless (plist-get size :file)
      (fancy-splash-generate-image
       (or (plist-get size :template)
           fancy-splash-image-template)
       (plist-get size :height)))))
(defun fancy-splash-ensure-theme-images-exist (&optional height)
  "Ensure that the relevant images exist.
Use the image of HEIGHT to check, defaulting to the height of the first
specification in `fancy-splash-sizes'. If that file does not exist for
the current theme, `fancy-splash-generate-all-images' is called. "
  (unless (file-exists-p
           (fancy-splash-filename
            (car custom-enabled-themes)
            fancy-splash-image-template
            (or height (plist-get (car fancy-splash-sizes) :height))))
    (fancy-splash-generate-all-images)))
#+end_src


#+begin_src emacs-lisp
(defun fancy-splash-clear-cache (&optional delete-files)
  "Clear all cached fancy splash images.
Optionally delete all cache files and regenerate the currently relevant set."
  (interactive (list t))
  (dolist (size fancy-splash-sizes)
    (unless (plist-get size :file)
      (let ((image-file
             (fancy-splash-filename
              (car custom-enabled-themes)
              (or (plist-get size :template)
                  fancy-splash-image-template)
              (plist-get size :height))))
        (image-flush (create-image image-file) t))))
  (message "Fancy splash image cache cleared!")
  (when delete-files
    (delete-directory fancy-splash-cache-dir t)
    (fancy-splash-generate-all-images)
    (message "Fancy splash images cache deleted!")))
#+end_src

#+begin_src emacs-lisp
(defun fancy-splash-switch-template ()
  "Switch the template used for the fancy splash image."
  (interactive)
  (let ((new (completing-read
              "Splash template: "
              (mapcar
               (lambda (template)
                 (replace-regexp-in-string "-template\\.svg$" "" template))
               (directory-files fancy-splash-image-directory nil "-template\\.svg\\'"))
              nil t)))
    (setq fancy-splash-image-template
          (expand-file-name (concat new "-template.svg") fancy-splash-image-directory))
    (fancy-splash-clear-cache)
    (message "") ; Clear message from `fancy-splash-clear-cache'.
    (setq fancy-splash--last-size nil)
    (fancy-splash-apply-appropriate-image)))
#+end_src

#+begin_src emacs-lisp
(defun fancy-splash-get-appropriate-size ()
  "Find the firt `fancy-splash-sizes' with min-height of at least frame height."
  (let ((height (frame-height)))
    (cl-some (lambda (size) (when (>= height (plist-get size :min-height)) size))
             fancy-splash-sizes)))
#+end_src

#+begin_src emacs-lisp
(setq fancy-splash--last-size nil)
(setq fancy-splash--last-theme nil)
(defun fancy-splash-apply-appropriate-image (&rest _)
  "Ensure the appropriate splash image is applied to the dashboard.
This function's signature is \"&rest _\" to allow it to be used
in hooks that call functions with arguments."
  (let ((appropriate-size (fancy-splash-get-appropriate-size)))
    (unless (and (equal appropriate-size fancy-splash--last-size)
                 (equal (car custom-enabled-themes) fancy-splash--last-theme))
      (unless (plist-get appropriate-size :file)
        (fancy-splash-ensure-theme-images-exist (plist-get appropriate-size :height)))
      (setq fancy-splash-image
            (or (plist-get appropriate-size :file)
                (fancy-splash-filename (car custom-enabled-themes)
                                       fancy-splash-image-template
                                       (plist-get appropriate-size :height)))
            +doom-dashboard-banner-padding (plist-get appropriate-size :padding)
            fancy-splash--last-size appropriate-size
            fancy-splash--last-theme (car custom-enabled-themes))
      (+doom-dashboard-reload))))
(defun doom-dashboard-draw-ascii-emacs-banner-fn ()
  (let* ((banner
          '(",---.,-.-.,---.,---.,---."
            "|---'| | |,---||    `---."
            "`---'` ' '`---^`---'`---'"))
         (longest-line (apply #'max (mapcar #'length banner))))
    (put-text-property
     (point)
     (dolist (line banner (point))
       (insert (+doom-dashboard--center
                +doom-dashboard--width
                (concat
                 line (make-string (max 0 (- longest-line (length line)))
                                   32)))
               "\n"))
     'face 'doom-dashboard-banner)))
#+end_src

#+begin_src emacs-lisp
(unless (display-graphic-p) ; for some reason this messes up the graphical splash screen atm
  (setq +doom-dashboard-ascii-banner-fn #'doom-dashboard-draw-ascii-emacs-banner-fn))
#+end_src

#+begin_src emacs-lisp
(defvar splash-phrase-source-folder
  (expand-file-name "misc/splash-phrases" doom-private-dir)
  "A folder of text files with a fun phrase on each line.")
#+end_src

#+begin_src emacs-lisp
(defvar splash-phrase-sources
  (let* ((files (directory-files splash-phrase-source-folder nil "\\.txt\\'"))
         (sets (delete-dups (mapcar
                             (lambda (file)
                               (replace-regexp-in-string "\\(?:-[0-9]+-\\w+\\)?\\.txt" "" file))
                             files))))
    (mapcar (lambda (sset)
              (cons sset
                    (delq nil (mapcar
                               (lambda (file)
                                 (when (string-match-p (regexp-quote sset) file)
                                   file))
                               files))))
            sets))
  "A list of cons giving the phrase set name, and a list of files which contain phrase components.")
#+end_src

#+begin_src emacs-lisp
(defvar splash-phrase-set
  (nth (random (length splash-phrase-sources)) (mapcar #'car splash-phrase-sources))
  "The default phrase set. See `splash-phrase-sources'.")
#+end_src

#+begin_src emacs-lisp
(defun splash-phrase-set-random-set ()
  "Set a new random splash phrase set."
  (interactive)
  (setq splash-phrase-set
        (nth (random (1- (length splash-phrase-sources)))
             (cl-set-difference (mapcar #'car splash-phrase-sources) (list splash-phrase-set))))
  (+doom-dashboard-reload t))
#+end_src

#+begin_src emacs-lisp
(defun splash-phrase-select-set ()
  "Select a specific splash phrase set."
  (interactive)
  (setq splash-phrase-set (completing-read "Phrase set: " (mapcar #'car splash-phrase-sources)))
  (+doom-dashboard-reload t))
#+end_src

#+begin_src emacs-lisp
(defvar splash-phrase--cached-lines nil)
#+end_src

#+begin_src emacs-lisp
(defun splash-phrase-get-from-file (file)
  "Fetch a random line from FILE."
  (let ((lines (or (cdr (assoc file splash-phrase--cached-lines))
                   (cdar (push (cons file
                                     (with-temp-buffer
                                       (insert-file-contents (expand-file-name file splash-phrase-source-folder))
                                       (split-string (string-trim (buffer-string)) "\n")))
                               splash-phrase--cached-lines)))))
    (nth (random (length lines)) lines)))
#+end_src

#+begin_src emacs-lisp
(defun splash-phrase (&optional set)
  "Construct a splash phrase from SET. See `splash-phrase-sources'."
  (mapconcat
   #'splash-phrase-get-from-file
   (cdr (assoc (or set splash-phrase-set) splash-phrase-sources))
   " "))
#+end_src

#+begin_src emacs-lisp
(defun splash-phrase-dashboard-formatted ()
  "Get a splash phrase, flow it over multiple lines as needed, and fontify it."
  (mapconcat
   (lambda (line)
     (+doom-dashboard--center
      +doom-dashboard--width
      (with-temp-buffer
        (insert-text-button
         line
         'action
         (lambda (_) (+doom-dashboard-reload t))
         'face 'doom-dashboard-menu-title
         'mouse-face 'doom-dashboard-menu-title
         'help-echo "Random phrase"
         'follow-link t)
        (buffer-string))))
   (split-string
    (with-temp-buffer
      (insert (splash-phrase))
      (setq fill-column (min 70 (/ (* 2 (window-width)) 3)))
      (fill-region (point-min) (point-max))
      (buffer-string))
    "\n")
   "\n"))
#+end_src

#+begin_src emacs-lisp
(defun splash-phrase-dashboard-insert ()
  "Insert the splash phrase surrounded by newlines."
  (insert "\n" (splash-phrase-dashboard-formatted) "\n"))
#+end_src


#+begin_src emacs-lisp
(defun +doom-dashboard-setup-modified-keymap ()
  (setq +doom-dashboard-mode-map (make-sparse-keymap))
  (map! :map +doom-dashboard-mode-map
        :desc "Find file" :ng "f" #'find-file
        :desc "Recent files" :ng "r" #'consult-recent-file
        :desc "Config dir" :ng "C" #'doom/open-private-config
        :desc "Open config.org" :ng "c" (cmd! (find-file (expand-file-name "config.org" doom-user-dir)))
        :desc "Open org-mode root" :ng "O" (cmd! (find-file (expand-file-name "lisp/org/" doom-user-dir)))
        :desc "Open dotfile" :ng "." (cmd! (doom-project-find-file "~/.config/"))
        :desc "Notes (roam)" :ng "n" #'org-roam-node-find
        :desc "Switch buffer" :ng "b" #'+vertico/switch-workspace-buffer
        :desc "Switch buffers (all)" :ng "B" #'consult-buffer
        :desc "IBuffer" :ng "i" #'ibuffer
        :desc "Previous buffer" :ng "p" #'previous-buffer
        :desc "Set theme" :ng "t" #'consult-theme
        :desc "Quit" :ng "Q" #'save-buffers-kill-terminal
        :desc "Search" :ng "o" #'eaf-open-browser-with-history
        :desc "Show keybindings" :ng "h" (cmd! (which-key-show-keymap '+doom-dashboard-mode-map))))
#+end_src

#+begin_src emacs-lisp
(add-transient-hook! #'+doom-dashboard-mode (+doom-dashboard-setup-modified-keymap))
(add-transient-hook! #'+doom-dashboard-mode :append (+doom-dashboard-setup-modified-keymap))
(add-hook! 'doom-init-ui-hook :append (+doom-dashboard-setup-modified-keymap))
#+end_src

#+begin_src emacs-lisp
(map! :leader :desc "Dashboard" "o s d" #'+doom-dashboard/open)
#+end_src

#+begin_src emacs-lisp
(defun +doom-dashboard-benchmark-line ()
  "Insert the load time line."
  (when doom-init-time
    (insert
     "\n\n"
     (propertize
      (+doom-dashboard--center
       +doom-dashboard--width
       (doom-display-benchmark-h 'return))
      'face 'doom-dashboard-loaded))))
#+end_src

#+begin_src emacs-lisp
(remove-hook 'doom-after-init-hook #'doom-display-benchmark-h)
#+end_src

#+begin_src emacs-lisp
(setq +doom-dashboard-functions
      (list #'doom-dashboard-widget-banner
            #'+doom-dashboard-benchmark-line
            #'splash-phrase-dashboard-insert))
#+end_src

#+begin_src emacs-lisp
(add-hook 'window-size-change-functions #'fancy-splash-apply-appropriate-image)
(add-hook 'doom-load-theme-hook #'fancy-splash-apply-appropriate-image)
#+end_src

#+begin_src emacs-lisp
(setq frame-title-format
      '(""
        (:eval
         (if (string-match-p (regexp-quote (or (bound-and-true-p org-roam-directory) "\u0000"))
                             (or buffer-file-name ""))
             (replace-regexp-in-string
              ".*/[0-9]*-?" "☰ "
              (subst-char-in-string ?_ ?\s buffer-file-name))
           "%b"))
        (:eval
         (when-let ((project-name (and (featurep 'projectile) (projectile-project-name))))
           (unless (string= "-" project-name)
             (format (if (buffer-modified-p)  " ◉ %s" "  ●  %s") project-name))))))
#+end_src

Setup End

* COMMENT Emacs Application Framework
#+begin_src emacs-lisp
(use-package! eaf
  :defer t
  :commands (eaf-open eaf-open-browser eaf-open-browser-other-window eaf-open-browser-with-history)
  ;;:load-path "~/.config/emacs/.local/straight/repos/emacs-application-framework"
  ;;:hook (eaf-mode . centaur-tabs-mode)
  :init
  ;; maps
  (map! :leader :desc "eaf search it"
        "o s e" #'eaf-search-it)
  (map! :leader :desc "eaf browser with history"
        "o s b" #'eaf-open-browser-with-history)
  :custom
  (eaf-browser-continue-where-left-off t)
  (eaf-browser-enable-adblocker t)
  :config
  (require 'eaf-browser)
  (require 'eaf-pdf-viewer)
  (require 'eaf-evil)
  (setq browse-url-browser-function 'eaf-open-browser)
  (setq eaf-evil-leader-key "C-SPC")
  (defalias 'browse-web #'eaf-open-browser)
  (eaf-bind-key scroll_up "C-n" eaf-pdf-viewer-keybinding)
  (eaf-bind-key scroll_down "C-p" eaf-pdf-viewer-keybinding)
  (eaf-bind-key nil "M-q" eaf-browser-keybinding)
  )
#+end_src
* Calulator
** CalcTex
For prettier lookup
#+begin_src emacs-lisp
(use-package! calctex
  :defer t
  :commands (calctex-mode calc)
  :init
  (add-hook 'calc-mode-hook #'calctex-mode)
  :config
  (setq calctex-additional-latex-packages "
\\usepackage[usenames]{xcolor}
\\usepackage{soul}
\\usepackage{adjustbox}
\\usepackage{amsmath,amsthm}
\\usepackage{cancel}
\\usepackage{mathtools}
\\usepackage{mathalpha}
\\usepackage{xparse}
\\usepackage{arevmath}"
        calctex-additional-latex-macros
        (concat calctex-additional-latex-macros
                "\n\\let\\evalto\\Rightarrow"))
  (defadvice! no-messaging-a (orig-fn &rest args)
    :around #'calctex-default-dispatching-render-process
    (let ((inhibit-message t) message-log-max)
      (apply orig-fn args)))
  ;; Fix hardcoded dvichop path (whyyyyyyy)
  (let ((vendor-folder (concat (file-truename doom-local-dir)
                               "straight/"
                               (format "build-%s" emacs-version)
                               "/calctex/vendor/")))
    (setq calctex-dvichop-sty (concat vendor-folder "texd/dvichop")
          calctex-dvichop-bin (concat vendor-folder "texd/dvichop")))
  (unless (file-exists-p calctex-dvichop-bin)
    (message "CalcTeX: Building dvichop binary")
    (let ((default-directory (file-name-directory calctex-dvichop-bin)))
      (call-process "make" nil nil nil))))
#+end_src

** Defaults
#+begin_src emacs-lisp
(setq calc-angle-mode 'rad  ; radians are rad
      calc-symbolic-mode t) ; keeps expressions like \sqrt{2} irrational for as long as possible
#+end_src

* Plaintext
#+begin_src emacs-lisp
(after! text-mode
  (add-hook! 'text-mode-hook
    (unless (derived-mode-p 'org-mode)
      ;; Apply ANSI color codes
      (with-silent-modifications
        (ansi-color-apply-on-region (point-min) (point-max) t)))))
#+end_src
* Org mode
** Org mode itself
#+begin_src emacs-lisp
(after! org
  ;;(org-num-mode t)
  (add-hook 'org-mode-hook 'org-display-inline-images)
  (require 'ox-extra)
  (ox-extras-activate '(ignore-headlines))
)
#+end_src

#+begin_src emacs-lisp
(use-package! org-contrib :config
  (require 'ox-extra)
  (ox-extras-activate '(ignore-headlines)))
#+end_src
** Transclusion
#+begin_src emacs-lisp
(use-package! org-transclusion
  :after org
  :commands org-transclusion-mode
  :init
  (map! :after org :map org-mode-map
        "<f12>" #'org-transclusion-mode))
#+end_src
** Import other files with pandoc
#+begin_src emacs-lisp
(use-package! org-pandoc-import
  :after org)
#+end_src
** cdlatex
#+begin_src emacs-lisp
(add-hook 'org-mode-hook 'turn-on-org-cdlatex)
#+end_src

It's handy to be able to quickly insert environments with =C-c }=. I almost always
want to edit them afterwards though, so let's make that happen by default.
#+begin_src emacs-lisp
(defadvice! org-edit-latex-emv-after-insert ()
  :after #'org-cdlatex-environment-indent
  (org-edit-latex-environment))
#+end_src
** Reveal Export
#+begin_src emacs-lisp
(setq org-re-reveal-theme "white"
      org-re-reveal-transition "slide"
      org-re-reveal-plugins '(markdown notes math search zoom))
#+end_src
** Beamer
#+begin_src emacs-lisp
(setq org-beamer-theme "[progressbar=foot]metropolis")
#+end_src
** Org latex
#+begin_src emacs-lisp
(after! ox-latex
  (setq org-latex-pdf-process '("latexmk -xelatex -quiet -shell-escape -f %f"))
  (setq org-latex-src-block-backend 'minted)
  (add-to-list 'org-latex-classes
               '("article"
                 "\\documentclass[12pt,a4paper]{report}
\\usepackage{graphicx}
\\usepackage{xcolor}
\\usepackage{xeCJK}
\\usepackage{enumitem}
\\usepackage{threeparttable}
\\usepackage{marginnote}
\\usepackage{cleveref}
\\usepackage[framemethod=TikZ]{mdframed}
\\usepackage{lmodern}
\\usepackage{verbatim}
\\usepackage{amsmath, amsthm}
\\usepackage{minted}
\\usepackage{fixltx2e}
\\usepackage{longtable}
\\usepackage{float}
\\usepackage{tikz}
\\usepackage{wrapfig}
\\usepackage{soul}
\\usepackage{textcomp}
\\usepackage{listings}
\\usepackage{geometry}
\\usepackage{algorithm}
\\usepackage[noend]{algpseudocode}
\\usepackage{marvosym}
\\usepackage{wasysym}
\\usepackage{latexsym}
\\usepackage{natbib}
\\usepackage{fancyhdr}
\\usepackage{cancel}
\\usepackage{mathtools}
\\usepackage[xetex,colorlinks=true,CJKbookmarks=true, linkcolor=blue, urlcolor=blue, menucolor=blue]{hyperref}
\\usepackage{fontspec,xunicode,xltxtra}
\\newfontinstance\\MONO{\\fontnamemono}
\\newcommand{\\mono}[1]{{\\MONO #1}}
\\setCJKmainfont[Scale=0.9]{SimSun}%中文字体
\\setCJKmonofont[Scale=0.9]{SimSun}
\\hypersetup{unicode=true}
\\geometry{a4paper, textwidth=6.5in, textheight=10in,marginparsep=7pt, marginparwidth=.6in}
\\punctstyle{kaiming}

\\title{}
% 定义代码高亮风格
% \\usemintedstyle{manni} % 可以选择你喜欢的风格

% 设置代码背景色
\\setminted{bgcolor=white} % 对应于 listings 的 backgroundcolor

% 设置字体大小和样式，minted 没有直接的选项，但可以通过其他 LaTeX 命令来设置
\\setminted{fontsize=\\small, baselinestretch=1}

% 设置行号
\\setminted{linenos, numbersep=5pt, frame=lines, framesep=2mm}

% 设置页眉页脚的分隔线
\\renewcommand{\\headrulewidth}{0.4pt} % 页眉分隔线宽度
\\renewcommand{\\footrulewidth}{0pt} % 页脚分隔线宽度（0pt表示没有分隔线）
\\newtheorem{lemma}{Lemma}[chapter]
\\newtheorem{corollary}{Corollary}[chapter]
\\newtheorem{proposition}{Proposition}[chapter]

% 定义其他环境
\\newtheorem{ex}{Exercise}[chapter]
\\newtheorem{notation}{Notation}[chapter]
\\newtheorem{remark}{Remark}[chapter]

\\newtheorem{theorem}{Theorem}[chapter]
\\newtheorem{definition}{Definition}[chapter]
\\newtheorem{exm}{Example}[chapter]
\\pagestyle{fancy}
\\fancyhf{}
\\renewcommand{\\chaptermark}[1]{\\markboth{#1}{}} % 修改页眉的chaptermark
\\fancyfoot[R]{\\thepage}
\\fancyhead{} % 页眉清空
\\fancyhead[R]{%
   % The chapter number only if it's greater than 0
   \\ifnum\\value{chapter}>0 \\chaptername\ \\thechapter: \\fi
   % The chapter title
   \\leftmark}
\\fancypagestyle{plain}{
\\fancyhead{} % 页眉清空
\\renewcommand{\\headrulewidth}{0pt} % 去页眉线
\\fancyfoot{}
\\fancyfoot[R]{\\thepage}
}
\\tolerance=1000

[NO-DEFAULT-PACKAGES]
[NO-PACKAGES]
[EXTRA]"
                 ("\\chapter{%s}" . "\\chapter*{%s}")
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                 ("\\paragraph{%s}" . "\\paragraph*{%s}")
                 ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))

;; 使用Listings宏包格式化源代码(只是把代码框用listing环境框起来，还需要额外的设置)
(setq org-export-latex-listings t)
;; Options for \lset command（reference to listing Manual)
;; 导出Beamer的设置
;; allow for export=>beamer by placing #+LaTeX_CLASS: beamer in org files
;;-----------------------------------------------------------------------------
(add-to-list 'org-latex-classes
             ;; beamer class, for presentations
             '("beamer"
               "\\documentclass[11pt,professionalfonts]{beamer}
\\mode

\\setbeamertemplate{footline}[frame number]{}
\\setbeamertemplate{navigation symbols}{}

\\usecolortheme{lily}
\\setbeamercolor{block title}{bg=blue!20,fg=black}
\\setbeamercolor{block body}{bg = blue!10, fg = black}
\\setbeamertemplate{itemize item}[square]
\\setbeamercolor{itemize item}{fg = cyan}
\\setbeamercolor{enumerate item}{fg = cyan}

\\usetheme{default}
\\beamertemplatenavigationsymbolsempty
\\setbeamercolor{titlelike}{fg=cyan}
\\beamertemplateballitem
\\setbeameroption{show notes}
\\usepackage{graphicx}
\\usepackage{tikz}
\\usepackage{xcolor}
\\usepackage{xeCJK}
\\usepackage{amsmath}
\\usepackage{lmodern}
\\usepackage{fontspec,xunicode,xltxtra}
\\usepackage{polyglossia}
\\setmainfont{Times New Roman}
\\setCJKmainfont{SimSun}
\\setCJKmonofont{SimSun}
\\usepackage{verbatim}
\\usepackage{listings}
% \\institute{{{{beamerinstitute}}}}
\\subject{{{{beamersubject}}}}"
               ("\\section{%s}" . "\\section*{%s}")
               ("\\begin{frame}[fragile]\\frametitle{%s}"
                "\\end{frame}"
                "\\begin{frame}[fragile]\\frametitle{%s}"
                "\\end{frame}")))
)
#+end_src
** org noter deft
#+begin_src emacs-lisp
(setq deft-directory "~/projects")
(setq org-noter-notes-search-path '("~/projects"))
#+end_src
** COMMENT org media note
#+begin_src emacs-lisp
(after! org-media-note
  :hook (org-mode .  org-media-note-mode)
  :bind (
         ("H-v" . org-media-note-show-interface))  ;; 主功能入口
  :config
  (setq org-media-note-screenshot-image-dir "~/projects/imgs/")  ;; 用于存储视频截图的目录
  )
#+end_src

#+RESULTS:
: org-media-note-show-interface

** Pandoc
#+begin_src emacs-lisp
(after! ox-pandoc
  (setq org-pandoc-options-for-latex-pdf '((pdf-engine . "xelatex")
                                           (template . "eppdev-doc")
                                           ))
  (setq org-pandoc-options-for-docx '((reference-doc . "/home/peng/Documents/templates/template.docx")))
  )
#+end_src
** org capture
#+begin_src emacs-lisp
;; ============================================================================
;; Novel Writing Capture System — Fixed & Stable
;; ============================================================================
(after! org-capture
  ;; --------------------------------------------------------------------------
  ;; 1. File structure
  ;; --------------------------------------------------------------------------
  (defvar my/novel-org-path "~/projects/novel/org/"
    "Base path for all novel-related org files.")

  (defvar my/novel-files
    '(("inbox"      . "inbox.org")
      ("characters" . "characters.org")
      ("scenes"     . "scenes.org")
      ("world"      . "world.org")
      ("dialogue"   . "dialogue.org")
      ("research"   . "research.org")
      ("tasks"      . "tasks.org"))
    "Assoc list of novel org files (name . filename).")

  (defun my/novel-file (key)
    "Return full path for novel file KEY, or signal error if missing."
    (let ((fname (alist-get key my/novel-files nil nil #'string=)))
      (unless fname
        (error "Unknown novel file key: %s" key))
      (expand-file-name fname my/novel-org-path)))

  ;; Ensure the directory exists
  (unless (file-directory-p my/novel-org-path)
    (make-directory my/novel-org-path t))

  ;; --------------------------------------------------------------------------
  ;; 2. Utility: generate UUID IDs for linking
  ;; --------------------------------------------------------------------------
  (defun my/uuid ()
    "Generate a new org ID for capture entries."
    (when (require 'org-id nil t)
      (org-id-new)))

  ;; --------------------------------------------------------------------------
  ;; 3. Add capture templates safely
  ;; --------------------------------------------------------------------------
  (add-to-list 'org-capture-templates
               '("n" "Novel Writing") t)  ;; <- prefix key, valid now

  (add-to-list 'org-capture-templates
               `("ni" "Idea / Inbox" entry
                 (file+headline ,(my/novel-file "inbox") "Fleeting Ideas")
                 "* %? :idea:\n:PROPERTIES:\n:Created: %U\n:ID: %(my/uuid)\n:END:\n\n%i\n%a"
                 :empty-lines 1))

  (add-to-list 'org-capture-templates
               `("nc" "Character" entry
                 (file ,(my/novel-file "characters"))
                 ,(string-join
                   '("* %? :character:"
                     ":PROPERTIES:"
                     ":Created: %U"
                     ":ID: %(my/uuid)"
                     ":Alias:"
                     ":Role:"
                     ":Arc:"
                     ":END:"
                     "\n** Overview\n- Role in story:\n- One-line summary:\n\n"
                     "** Appearance\n- Physical description:\n\n"
                     "** Personality & Background\n- Traits & backstory:\n\n"
                     "** Motivation & Conflict\n- Drives:\n- Obstacles:\n\n"
                     "** Relationships\n- Key connections:\n\n"
                     "** Arc Notes\n\n")
                   "\n")
                 :empty-lines 1))

  (add-to-list 'org-capture-templates
               `("ns" "Scene / Plot Point" entry
                 (file+headline ,(my/novel-file "scenes") "Scenes")
                 ,(string-join
                   '("* %? :scene:"
                     ":PROPERTIES:"
                     ":Created: %U"
                     ":ID: %(my/uuid)"
                     ":Location:"
                     ":Time:"
                     ":POV:"
                     ":Characters:"
                     ":WorldRefs:"
                     ":Status: idea"
                     ":END:"
                     "\n** Logline\nOne-sentence summary of the scene.\n\n"
                     "** Purpose\n- Function in story:\n- Stakes:\n\n"
                     "** Outline\n1. Setup\n2. Conflict\n3. Resolution\n\n"
                     "** Emotional Arc\n- POV emotional change:\n\n"
                     "** Sensory Details\nSight / Sound / Smell / Touch / Taste:\n\n"
                     "** Notes\n\n")
                   "\n")
                 :empty-lines 1))

  (add-to-list 'org-capture-templates
               `("nw" "Worldbuilding / Lore" entry
                 (file+headline ,(my/novel-file "world") "World Notes")
                 ,(string-join
                   '("* %? :world:"
                     ":PROPERTIES:"
                     ":Created: %U"
                     ":ID: %(my/uuid)"
                     ":Category:"
                     ":END:"
                     "\n** Description\n\n"
                     "** Connections\nLinks to: [[id:]]\n\n"
                     "** Story Relevance\n\n")
                   "\n")
                 :empty-lines 1))

  (add-to-list 'org-capture-templates
               `("nd" "Dialogue Snippet" entry
                 (file+headline ,(my/novel-file "dialogue") "Fragments")
                 "* %U :dialogue:\n%?\n"
                 :empty-lines 1))

  (add-to-list 'org-capture-templates
               `("nr" "Research Note" entry
                 (file+headline ,(my/novel-file "research") "Notes")
                 "* %? :research:\n:PROPERTIES:\n:Created: %U\n:Source: %a\n:END:\n\n%i\n"
                 :empty-lines 1))

  (add-to-list 'org-capture-templates
               `("nt" "Writing Task" entry
                 (file+headline ,(my/novel-file "tasks") "Writing Tasks")
                 "* TODO %?\nSCHEDULED: %(org-insert-time-stamp (org-read-date nil t \"+1d\"))\n:PROPERTIES:\n:Created: %U\n:END:"
                 :empty-lines 1))
  )
#+end_src
** org columns
*** basics
#+begin_src emacs-lisp
(use-package! org-ql :ensure t)

(setq org-columns-default-format
      "%25ITEM(Task) %10ID(ID) %10POV(POV) %20Goal(Goal) %15Status(Status) %6Words(Words) %TAGS")

(defun my/novel-collect-scenes-from-current-buffer ()
  "从当前 Org buffer 中收集所有带 :scene: 标签的条目，并返回一个 plists 列表。
该函数会收集 :title :id :pov :goal :tensionscore :outcome :status :words :next 这些属性。"
  (unless (derived-mode-p 'org-mode)
    (error "This function must be run in an Org mode buffer"))
  (org-with-wide-buffer
    (let (out)
      (org-map-entries
       (lambda ()
         (let* ((title (nth 4 (org-heading-components)))
                (id    (org-entry-get nil "ID"))
                (pov   (org-entry-get nil "POV"))
                (goal  (org-entry-get nil "Goal"))
                (tensionscore (org-entry-get nil "TensionScore"))
                (outcome (org-entry-get nil "Outcome"))
                (status  (org-entry-get nil "Status"))
                (words   (org-entry-get nil "Words"))
                (next    (org-entry-get nil "Next")))
           (push (list :title title :id id :pov pov :goal goal
                       :tensionscore tensionscore :outcome outcome :status status
                       :words (when words (string-to-number words))
                       :next next)
                 out)))
       ;; --- 这是关键的修改 ---
       ;; 仅匹配层级为 1 (一个星号) 且带有 "scene" 标签的标题
       "+scene+LEVEL=1")
      (nreverse out))))

(defun my/novel-scenes-to-table ()
  "为当前 Org 文件中的所有场景生成一个 Org 表格，并在新 buffer 中显示。
表格包含 Scene, ID, POV, Goal, TensionScore, Outcome, Status, Words 列。"
  (interactive)
  (let ((rows (my/novel-collect-scenes-from-current-buffer)))
    (with-current-buffer (get-buffer-create "*Novel Scenes Table*")
      (setq-local buffer-read-only nil)
      (erase-buffer)
      (insert "| Scene | ID | POV | Goal | TensionScore | Outcome | Status | Words |\n")
      (insert "|-\n")
      (dolist (s rows)
        (insert (format "| %s | %s | %s | %s | %s | %s | %s | %s |\n"
                        (or (plist-get s :title) "")
                        (or (plist-get s :id) "")
                        (or (plist-get s :pov) "")
                        (or (plist-get s :goal) "")
                        (or (plist-get s :tensionscore) "")
                        (or (plist-get s :outcome) "")
                        (or (plist-get s :status) "")
                        (or (plist-get s :words) ""))))
      (org-mode)
      (org-table-align)
      (goto-char (point-min))
      (display-buffer (current-buffer)))))
#+end_src
*** export to csv

#+begin_src emacs-lisp
;; --- 增强版场景数据收集与 CSV 导出工具 ---

(defun my/org-get-text-under-subheading (subheading)
  "在当前 org-map-entries 的范围内，查找名为 SUBHEADING 的子标题并返回其下方的所有文本内容。
此版本使用更健壮的 org-element API。"
  (require 'org-element) ; 同样需要 require
  (save-excursion
    (let ((case-fold-search t)
          (re (format "^\\*\\* %s" (regexp-quote subheading))))
      (if (re-search-forward re nil t)
          ;; 使用 org-element API 解析当前标题
          (let* ((element (org-element-at-point))
                 (begin (org-element-property :contents-begin element))
                 (end (org-element-property :contents-end element)))
            (if (and begin end)
                (string-trim (buffer-substring-no-properties begin end))
              ""))
        ""))))

(defun my/novel-collect-rich-scene-data ()
  "从当前 Org buffer 中收集所有带 :scene: 标签的条目及其详细数据。
此版本会自动清理 ID 和 Next 属性中的 'id:' 前缀。"
  (unless (derived-mode-p 'org-mode)
    (error "This function must be run in an Org mode buffer"))
  (require 'org-element)
  (org-with-wide-buffer
    (let (out)
      (org-map-entries
       (lambda ()
         (let* (;; --- 这是关键的修改 ---
                (id-raw (org-entry-get nil "ID"))
                (next-raw (org-entry-get nil "Next"))
                (id (when id-raw (replace-regexp-in-string "^id:" "" id-raw)))
                ;; 对 Next 字段中的所有 "id:" 都进行替换
                (next (when next-raw (replace-regexp-in-string "id:" "" next-raw)))

                (plist (list
                        :title (nth 4 (org-heading-components))
                        :id id ; 使用清理后的 id
                        :pov (org-entry-get nil "POV")
                        :location (org-entry-get nil "Location")
                        :time (org-entry-get nil "Time")
                        :goal (org-entry-get nil "Goal")
                        :conflict (org-entry-get nil "Conflict")
                        :tensionscore (org-entry-get nil "TensionScore")
                        :outcome (org-entry-get nil "Outcome")
                        :status (org-entry-get nil "Status")
                        :words (let ((w (org-entry-get nil "Words")))
                                 (when w (string-to-number w)))
                        :arc (org-entry-get nil "Arc")
                        :characters (org-entry-get nil "Characters")
                        :next next ; 使用清理后的 next
                        :summary (my/org-get-text-under-subheading "概述 (Summary)")
                        :notes (my/org-get-text-under-subheading "笔记 (Notes)"))))
           (push plist out)))
       "+scene+LEVEL=1")
      (nreverse out))))

(defun my/csv-quote (str)
  "为 CSV 格式正确地引用字符串。
如果字符串包含逗号、双引号或换行符，则用双引号包裹它，
并将内部的双引号替换为两个双引号。"
  (let ((s (if (stringp str) str (format "%s" (or str "")))))
    (if (string-match "[\",\n]" s)
        (concat "\"" (string-replace "\"" "\"\"" s) "\"")
      s)))
(defun my/novel-export-scenes-to-csv (&optional file-path)
  "将当前 Org 文件中的所有场景数据导出为 CSV 文件。
如果 FILE-PATH 未提供，则会交互式地询问用户。
成功时返回导出的文件路径，否则返回 nil。"
  (interactive)
  (let* ((rows (my/novel-collect-rich-scene-data))
         (output-path (or file-path (read-file-name "Export CSV to file: " nil nil t "scenes.csv")))
         ;; --- 关键行 ---
         ;; 确保 headers 列表中包含小写的 :tensionscore
         (headers '(:id :title :status :pov :goal :conflict :outcome :tensionscore :arc :characters :location :time :words :summary :notes :next)))
    (when (and rows output-path)
      (with-temp-buffer
        (insert (mapconcat #'symbol-name headers ",") "\n")
        (dolist (s rows)
          (let ((line (mapconcat
                       (lambda (key) (my/csv-quote (plist-get s key)))
                       headers
                       ",")))
            (insert line "\n")))
        (write-region (point-min) (point-max) output-path nil))
      (message "Successfully exported %d scenes to %s" (length rows) output-path)
      output-path)))

;; --- 新增：可视化启动器 ---
(defvar my/novel-visualization-script
  (expand-file-name "scripts/visualize_novel.py" doom-private-dir)
  "指向用于可视化小说数据的 Python 脚本的路径。")

(defun my/novel-visualize-data-with-python ()
  "一键工作流：导出场景数据到 CSV，然后调用 Python 脚本生成可视化图表。"
  (interactive)
  (let* ((csv-dir (or buffer-file-name default-directory))
         (csv-file (expand-file-name "scenes_data.csv" (file-name-directory csv-dir)))
         (exported-path (my/novel-export-scenes-to-csv csv-file)))
    (if (and exported-path (file-exists-p my/novel-visualization-script))
        (progn
          (message "CSV exported. Now running Python visualization script...")
          ;; 异步执行脚本，避免冻结 Emacs
          (async-shell-command (format "python %s %s"
                                       (shell-quote-argument my/novel-visualization-script)
                                       (shell-quote-argument exported-path)))
          (message "Python script started asynchronously. A plot window should appear soon."))
      (unless exported-path
        (warn "CSV export was cancelled or failed."))
      (unless (file-exists-p my/novel-visualization-script)
        (warn "Visualization script not found at: %s" my/novel-visualization-script)))))
#+end_src
*** export to excel
#+begin_src emacs-lisp :tangle yes

#+end_src

#+begin_src emacs-lisp
;; --- 新增：用于调用 Excel 转换脚本的变量和函数 ---

(defvar my/novel-excel-converter-script
  (expand-file-name "scripts/csv_to_styled_xlsx.py" doom-private-dir)
  "指向用于将 CSV 转换为格式化 Excel 文件的 Python 脚本的路径。")

(defun my/novel-export-to-excel ()
  "一键工作流：导出场景数据到 CSV，然后调用 Python 脚本将其转换为格式精美的 XLSX 文件。"
  (interactive)
  (let* ((csv-dir (or buffer-file-name default-directory))
         (csv-file (expand-file-name "scenes_data.csv" (file-name-directory csv-dir)))
         ;; 步骤 1: 调用我们已有的函数导出 CSV
         (exported-path (my/novel-export-scenes-to-csv csv-file)))
    ;; 步骤 2: 如果 CSV 导出成功，则调用新的 Python 脚本
    (if (and exported-path (file-exists-p my/novel-excel-converter-script))
        (progn
          (message "CSV exported. Now converting to styled XLSX...")
          (async-shell-command (format "python3 %s %s > /dev/null &"
                                       (shell-quote-argument my/novel-excel-converter-script)
                                       (shell-quote-argument exported-path)))
          (message "Python script started asynchronously. The .xlsx file will be created soon."))
      (unless exported-path
        (warn "CSV export was cancelled or failed."))
      (unless (file-exists-p my/novel-excel-converter-script)
        (warn "Excel converter script not found at: %s" my/novel-excel-converter-script)))))
#+end_src
** org id
#+begin_src emacs-lisp
(require 'org-id)
(setq org-id-link-to-org-use-id t)

(defun mcj/org-id-create ()
  "Create and store a human readable ID for the current heading."
  (let* ((title (or (nth 4 (org-heading-components)) ""))
         (san (replace-regexp-in-string "[^[[:alpha:]]]+" "_" (downcase title)))
         (san (replace-regexp-in-string "^_+\\|_+$" "" san))
         (new-id (format "L%s_%s" (format-time-string "%Y%m%d.%H%M%S") (if (string= san "") "untitled" san))))
    (org-entry-put nil "ID" new-id)
    ;; register to org-id locations
    (org-id-add-location new-id (or (buffer-file-name (buffer-base-buffer)) (buffer-file-name)))))

(defun mcj/org-id-get-or-create ()
  "Return the ID of the current entry, creating one if absent."
  (let ((old (org-entry-get nil "ID")))
    (if (and old (stringp old) (> (length old) 0))
        old
      (mcj/org-id-create)
      (org-entry-get nil "ID"))))
(defun mcj/org-id-create-if-needed ()
  "If the current node does not have a ID, create one."
  (interactive)
  (org-with-point-at nil
    (let ((old-id (org-entry-get nil "ID")))
      (if (and old-id (stringp old-id))
          (when (called-interactively-p 'any)
            (message "ID already exists. Not overwriting it."))
        (mcj/org-id-create)))))

;; Add mcj/org-id-create-if-needed as advice. For this we need a wrapper function that passes its argument to org-store-link
(defun mcj/org-id-advice (&rest _args)
  (when (org-before-first-heading-p)
    ;; nothing to do if not in heading - optional guard
    )
  (mcj/org-id-get-or-create)
  (org-id-update-id-locations))

(advice-add 'org-store-link :before #'mcj/org-id-advice)

(defun novel-auto-generate-id-after-snippet ()
  (when (looking-back "temp-id-placeholder" (line-beginning-position))
    (delete-region (line-beginning-position) (line-end-position))
    (mcj/org-id-get-or-create)))
(add-hook 'yas-after-exit-snippet-hook #'novel-auto-generate-id-after-snippet)

#+end_src

#+RESULTS:
| novel-auto-generate-id-after-snippet |

* Nov.el
Reading ~epub~ books
#+begin_src emacs-lisp
(add-to-list 'auto-mode-alist '("\\.epub\\'" . nov-mode))
#+end_src
* pyim
#+begin_src emacs-lisp
 (set-language-environment "UTF-8")
(after! pyim
  (require 'pyim-cregexp-utils)
  (require 'pyim-liberime)
  ;; 如果使用 popup page tooltip, 就需要加载 popup 包。
  ;; (require 'popup nil t)
  (setq pyim-page-tooltip 'posframe)

  ;; 如果使用 pyim-dregcache dcache 后端，就需要加载 pyim-dregcache 包。
  ;; (require 'pyim-dregcache)
  ;; (setq pyim-dcache-backend 'pyim-dregcache)

  ;; 加载 basedict 拼音词库。
  (pyim-basedict-enable)

  ;; 将 Emacs 默认输入法设置为 pyim.
  (setq default-input-method "pyim")

  ;; 显示 5 个候选词。
  (setq pyim-page-length 5)

  ;; 金手指设置，可以将光标处的编码（比如：拼音字符串）转换为中文。
  (global-set-key (kbd "M-j") 'pyim-convert-string-at-point)

  ;; 按 "C-<return>" 将光标前的 regexp 转换为可以搜索中文的 regexp.
  (define-key minibuffer-local-map (kbd "C-<return>") 'pyim-cregexp-convert-at-point)

  ;; 设置 pyim 默认使用的输入法策略，我使用全拼。
  (pyim-default-scheme 'ziranma-shuangpin)
  ;; (pyim-default-scheme 'wubi)
  ;; (pyim-default-scheme 'cangjie)

  ;; 设置 pyim 是否使用云拼音。
  (setq pyim-cloudim 'baidu)

  ;; 设置 pyim 探针
  ;; 我自己使用的中英文动态切换规则是：
  ;; 1. 光标只有在注释里面时，才可以输入中文。
  ;; 2. 光标前是汉字字符时，才能输入中文。
  ;; 3. 使用 M-j 快捷键，强制将光标前的拼音字符串转换为中文。
  (setq-default pyim-english-input-switch-functions
                '(pyim-probe-org-structure-template))

  (setq-default pyim-punctuation-half-width-functions
                '(pyim-probe-punctuation-line-beginning
                  pyim-probe-punctuation-after-punctuation))

  ;; 开启代码搜索中文功能（比如拼音，五笔码等）
  (pyim-isearch-mode 1)
)

(use-package! pyim-basedict
  :after pyim)
#+end_src
* Dired
** Dired open in xdg-open
#+begin_src emacs-lisp

(after! dired
  (defun my/dired-xdg-open ()
    "Open the file at point in Dired using xdg-open."
    (interactive)
    (let ((file (dired-get-file-for-visit)))
      (if (file-directory-p file)
          (dired-find-file) ; Open directory in Dired
        (start-process "xdg-open" nil "xdg-open" file))))

  (define-key dired-mode-map (kbd "M-o") 'my/dired-xdg-open)
  )
#+end_src


orgit:~/.config/doom
